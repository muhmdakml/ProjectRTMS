//******************************************************************************//
//	NAME 			: MUHAMMAD AKMAL BIN MOHD ADZUDDIN							//
//	ID	 			: 25350														//
//	PROGRAMME 		: ELECTRICAL AND ELECTRONICS ENGINEERING					//
//	COURSE 			: EDB 4123 REAL TIME MICROCONTROLLER SYSTEMS (RTMS)	 		//
//	LECTURER 		:	DR PATRICK SEBASTIAN									//
//	BATCH			: JANUARY 2021 												//	
//																				//
//	PROJECT TITLE : DEFUSE THE BOMB (GAME)										//
//	FUNCTIONS UTILISED : 	1. LCD												//	
//							2. 7 SEGMENT (BLOCK 2 AND 3)						//
// 							3. KEYPAD											//
//							4. 4 RED LEDs										//
//							5. RGB LEDs											//
//							6. BUZZER											// 
//							7. ADC6 & ADC7 										//
//							8. TIMER0 TIMER1 TIMER3								//
//							9. RANDOM FUNCTION (SRAND)							//
//																				//
//																				//
//	COPYRIGHTS : NONE, FEEL FREE TO USE AND ADJUST 								//
//							 DO FOLLOW ME AT GITHUB.COM/MUHMDAKML			 	//
//							 THANK YOU ^___^								   	//
//******************************************************************************//

//DEFINING ALL THE LIBRARIES USED (ONLY NORMAL LIBRARIES)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "NUC1xx.h"
#include "GPIO.h"
#include "SYS.h"
#include "ADC.h"
#include "LCD.h"
#include "Scankey.h"
#include "Seven_Segment.h"

//DEFINING THE TIMER TYPES USED
#define  ONESHOT  0   // counting and interrupt when reach TCMPR number, then stop
#define  PERIODIC 1   // counting and interrupt when reach TCMPR number, then counting from 0 again
#define  TOGGLE   2   // keep counting and interrupt when reach TCMPR number, tout toggled (between 0 and 1)
#define  CONTINUOUS 3 // keep counting and interrupt when reach TCMPR number

//DEFINING FLAG AND LED STATE FOR ADC AMD TIMES
volatile uint8_t gu8AdcIntFlag;
volatile uint32_t ledState = 0;

									//PART 1
//DEFINE ALL TIMERS AND RELATED ITEMS
//******************************************************************************//
// DEFINE TIMER0 IRQ HANDLE
void TMR0_IRQHandler()
{
	
	ledState = ~ ledState;  // changing ON/OFF state
	if(ledState) DrvGPIO_ClrBit(E_GPC,12);
	else	DrvGPIO_SetBit(E_GPC,12);
	if(ledState) DrvGPIO_ClrBit(E_GPC,13);
	else	DrvGPIO_SetBit(E_GPC,13);
	if(ledState) DrvGPIO_ClrBit(E_GPC,14);
	else	DrvGPIO_SetBit(E_GPC,14);
	if(ledState) DrvGPIO_ClrBit(E_GPC,15);
	else	DrvGPIO_SetBit(E_GPC,15);
	
	TIMER0->TISR.TIF = 1;		// clear Interrupt flag	
}

// DEFINE TIMER1 IRQ HANDLE
void TMR1_IRQHandler()
{
	ledState = ~ ledState;  // changing ON/OFF state
	if(ledState) DrvGPIO_ClrBit(E_GPC,12);
	else	DrvGPIO_SetBit(E_GPC,12);
	if(ledState) DrvGPIO_ClrBit(E_GPC,13);
	else	DrvGPIO_SetBit(E_GPC,13);
	if(ledState) DrvGPIO_ClrBit(E_GPC,14);
	else	DrvGPIO_SetBit(E_GPC,14);
	if(ledState) DrvGPIO_ClrBit(E_GPC,15);
	else	DrvGPIO_SetBit(E_GPC,15);
	TIMER1->TISR.TIF = 1;		// clear Interrupt flag
}

// DEFINE TIMER2 IRQ HANDLE
void TMR2_IRQHandler()
{
	ledState = ~ ledState;  // changing ON/OFF state
	if(ledState) DrvGPIO_ClrBit(E_GPC,12);
	else	DrvGPIO_SetBit(E_GPC,12);
	if(ledState) DrvGPIO_ClrBit(E_GPC,13);
	else	DrvGPIO_SetBit(E_GPC,13);
	if(ledState) DrvGPIO_ClrBit(E_GPC,14);
	else	DrvGPIO_SetBit(E_GPC,14);
	if(ledState) DrvGPIO_ClrBit(E_GPC,15);
	else	DrvGPIO_SetBit(E_GPC,15);
	TIMER2->TISR.TIF = 1;		// clear Interrupt flag
}

// INITIALISE TIMER0 (CONTINOUOUS)
void InitTIMER0(void)
{   
	SYSCLK->CLKSEL1.TMR0_S = 0;	//Select 12Mhz for Timer0 clock source 
	SYSCLK->APBCLK.TMR0_EN = 1;	//Enable Timer0 clock source
	TIMER0->TCSR.MODE = PERIODIC; //Select operation mode
	TIMER0->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER0->TCMPR = 46875 * 0.5;		    // Set TCMPR [0~16777215]
	//Timeout period = (1 / 12MHz) * ( 255 + 1 ) * 46875 * 0.5 = 0.5 sec
	TIMER0->TCSR.IE = 1;
	TIMER0->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR0_IRQn);	//Enable Timer0 Interrupt
	TIMER0->TCSR.CRST = 1;	//Reset up counter
	TIMER0->TCSR.CEN = 1;		//Enable Timer0
}

// INITIALISE TIMER1 (CONTINOUOUS)
void InitTIMER1(void)
{      
	SYSCLK->CLKSEL1.TMR1_S = 0;	//Select 12Mhz for Timer1 clock source 
	SYSCLK->APBCLK.TMR1_EN = 1;	//Enable Timer0 clock source
	TIMER1->TCSR.MODE = PERIODIC; //Select operation mode
	TIMER1->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER1->TCMPR = 46875 * 0.25 ;		    // Set TCMPR [0~16777215]	
	//Timeout period = (1 / 12MHz) * ( 255 ) * 46875 * 0.5 = 0.25 sec
	TIMER1->TCSR.IE = 1;
	TIMER1->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR1_IRQn);	//Enable Timer0 Interrupt
	TIMER1->TCSR.CRST = 1;	//Reset up counter
	TIMER1->TCSR.CEN = 1;		//Enable Timer1
}

// INITIALISE TIMER2 (CONTINOUOUS)
void InitTIMER2(void)
{       
	SYSCLK->CLKSEL1.TMR2_S = 0;	//Select 12Mhz for Timer0 clock source 
	SYSCLK->APBCLK.TMR2_EN = 1;	//Enable Timer0 clock source
	TIMER2->TCSR.MODE = PERIODIC; //Select operation mode
	TIMER2->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER2->TCMPR = 46875 * 0.125 ;
	// Set TCMPR [0~16777215] //Timeout period = (1 / 12MHz) * (256) * 46875 * 0.125 = 0.125 sec
	TIMER2->TCSR.IE = 1;
	TIMER2->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR2_IRQn);	//Enable Timer0 Interrupt

	TIMER2->TCSR.CRST = 1;	//Reset up counter
	TIMER2->TCSR.CEN = 1;		//Enable Timer2

}

// INITIALISE TO DISABLE TIMER0
void DisableTIMER0(void)
{   
	SYSCLK->CLKSEL1.TMR0_S = 0;	//Select 12Mhz for Timer0 clock source 
	SYSCLK->APBCLK.TMR0_EN = 1;	//Enable Timer0 clock source
	TIMER0->TCSR.MODE = ONESHOT; //Select operation mode
	TIMER0->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER0->TCMPR = 46875;		    // Set TCMPR [0~16777215]
	//Timeout period = (1 / 12MHz) * ( 255 + 1 ) * 46875 = 1 sec
	TIMER0->TCSR.IE = 1;
	TIMER0->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR0_IRQn);	//Enable Timer0 Interrupt
	TIMER0->TCSR.CRST = 1;	//Reset up counter
	TIMER0->TCSR.CEN = 0;		//Disable Timer0
}

// INITIALISE TO DISABLE TIMER1
void DisableTIMER1(void)
{      
	SYSCLK->CLKSEL1.TMR1_S = 0;	//Select 12Mhz for Timer1 clock source 
	SYSCLK->APBCLK.TMR1_EN = 1;	//Enable Timer0 clock source
	TIMER1->TCSR.MODE = ONESHOT; //Select operation mode
	TIMER1->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER1->TCMPR = 46875 * 0.5 ;		    // Set TCMPR [0~16777215]	
	//Timeout period = (1 / 12MHz) * ( 255 ) * 46875 * 0.5 = 0.5 sec
	TIMER1->TCSR.IE = 1;
	TIMER1->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR1_IRQn);	//Enable Timer0 Interrupt
	TIMER1->TCSR.CRST = 1;	//Reset up counter
	TIMER1->TCSR.CEN = 0;		//Disable Timer1
}

// INITIALISE TO DISABLE TIMER2
void DisableTIMER2(void)
{       
	SYSCLK->CLKSEL1.TMR2_S = 0;	//Select 12Mhz for Timer0 clock source 
	SYSCLK->APBCLK.TMR2_EN = 1;	//Enable Timer0 clock source
	TIMER2->TCSR.MODE = ONESHOT; //Select operation mode
	TIMER2->TCSR.PRESCALE = 255;	// Set Prescale [0~255]
	TIMER2->TCMPR = 46875 * 0.25 ;
	// Set TCMPR [0~16777215] //Timeout period = (1 / 12MHz) * (256) * 46875 * 0.25 = 0.25 sec
	TIMER2->TCSR.IE = 1;
	TIMER2->TISR.TIF = 1;		//Write 1 to clear for safty		
	NVIC_EnableIRQ(TMR2_IRQn);	//Enable Timer0 Interrupt

	TIMER2->TCSR.CRST = 1;	//Reset up counter
	TIMER2->TCSR.CEN = 0;		//Disable Timer2
}

// INITIALISE TO SET ADC FLAG 
void AdcIntCallback(uint32_t u32UserData)
{
    gu8AdcIntFlag = 1;	
}
//******************************************************************************//

								//PART 2
// DEFINE GPIO / LED / LCD AND OTHER FUNCTIONS
//******************************************************************************//
void seg_display(int16_t value)
{
  int8_t digit;

	DrvSYS_Delay(25000);
	digit = value / 1000;
	value = value - digit * 1000;
	digit = value / 100;
	if (value > 100 )
		{
		close_seven_segment();	
		show_seven_segment(2,digit);
		}
	DrvSYS_Delay(25000);	
	

	value = value - digit * 100;
	digit = value / 10;
	close_seven_segment();	
	show_seven_segment(1,digit);

	
	value = value - digit * 10;
	digit = value;
}

void init_LED(void)
{	
	DrvGPIO_Open(E_GPC, 12, E_IO_OUTPUT); // GPC12 pin set to output mode
	DrvGPIO_SetBit(E_GPC, 12);            // Goutput Hi to turn off LED
	DrvGPIO_Open(E_GPC, 13, E_IO_OUTPUT); // GPC12 pin set to output mode
	DrvGPIO_SetBit(E_GPC, 13);            // Goutput Hi to turn off LED
	DrvGPIO_Open(E_GPC, 14, E_IO_OUTPUT); // GPC12 pin set to output mode
	DrvGPIO_SetBit(E_GPC, 14);            // Goutput Hi to turn off LED
	DrvGPIO_Open(E_GPC, 15, E_IO_OUTPUT); // GPC12 pin set to output mode
	DrvGPIO_SetBit(E_GPC, 15);            // Goutput Hi to turn off LED
	
	DrvGPIO_Open(E_GPA, 12, E_IO_OUTPUT); // GPA12 pin set to output mode
	DrvGPIO_Open(E_GPA, 13, E_IO_OUTPUT); // GPA13 pin set to output mode
	DrvGPIO_Open(E_GPA, 14, E_IO_OUTPUT); // GPA14 pin set to output mode
}

void DisableLED(void)
{	
	DrvGPIO_SetBit(E_GPC, 12); // output HIGH to turn OFF LED
	DrvGPIO_SetBit(E_GPC, 13); // output HIGH to turn OFF LED
	DrvGPIO_SetBit(E_GPC, 14); // output HIGH to turn OFF LED	
	DrvGPIO_SetBit(E_GPC, 15); // output HIGH to turn OFF LED
}

void KnightRiderLED(void)
{
	int u=3;
	while(u > 0)
	{
	DrvGPIO_ClrBit(E_GPC, 12); // output Low to turn on LED
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_ClrBit(E_GPC, 13); // output Low to turn on LED
	DrvSYS_Delay(50000);	   // delay 		
	DrvGPIO_ClrBit(E_GPC, 14); // output Low to turn on LED		
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_ClrBit(E_GPC, 15); // output Low to turn on LED
	DrvSYS_Delay(50000);	   // delay
	
	DrvGPIO_SetBit(E_GPC, 12); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 13); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 14); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 15); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
		
	DrvGPIO_ClrBit(E_GPC, 15); // output Low to turn on LED
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_ClrBit(E_GPC, 14); // output Low to turn on LED
	DrvSYS_Delay(50000);	   // delay 		
	DrvGPIO_ClrBit(E_GPC, 13); // output Low to turn on LED		
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_ClrBit(E_GPC, 12); // output Low to turn on LED	
	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 15); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 14); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 13); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay 
	DrvGPIO_SetBit(E_GPC, 12); // output Hi to turn off LED	
	DrvSYS_Delay(50000);	   // delay	
	u--;
	}
}

void CelebrationLED(void)
{
	int u = 3;
	while (u > 0)
	{	
		DrvGPIO_ClrBit(E_GPA, 12); // output Low to turn on RED LED
		  DrvSYS_Delay(300000);	     // delay
		DrvGPIO_ClrBit(E_GPA, 13); // output Low to turn on GREEN LED
		  DrvSYS_Delay(300000);	     // delay
		DrvGPIO_ClrBit(E_GPA, 14); // output Low to turn on BLUE LED
		  DrvSYS_Delay(300000);	     // delay
	
	  DrvGPIO_SetBit(E_GPA, 12); // output Hi to turn off RED LED
		  DrvSYS_Delay(300000);	     // delay
	  DrvGPIO_SetBit(E_GPA, 13); // output Hi to turn off GREEN LED
		  DrvSYS_Delay(300000);	     // delay
	  DrvGPIO_SetBit(E_GPA, 14); // output Hi to turn off BLUE LED
	  DrvSYS_Delay(300000);	     // delay
	u--;
	}
}
void BombDetonate(void)
{
		int u = 3;
	while (u > 0)
	{
		DrvGPIO_ClrBit(E_GPB,11); // GPB11 = 0 to turn on Buzzer
	  DrvSYS_Delay(300000);	 // Delay 
	  DrvGPIO_SetBit(E_GPB,11); // GPB11 = 1 to turn off Buzzer	
	  DrvSYS_Delay(100000);	 // Delay
		u--;
	}
}

void BombDefused(void)
{
		int u = 3;
	while (u > 0)
	{
		DrvGPIO_ClrBit(E_GPB,11); // GPB11 = 0 to turn on Buzzer
	  DrvSYS_Delay(50000);	 // Delay 
	  DrvGPIO_SetBit(E_GPB,11); // GPB11 = 1 to turn off Buzzer	
	  DrvSYS_Delay(100000);	 // Delay
		DrvGPIO_ClrBit(E_GPB,11); // GPB11 = 0 to turn on Buzzer
	  DrvSYS_Delay(150000);	 // Delay 
	  DrvGPIO_SetBit(E_GPB,11); // GPB11 = 1 to turn off Buzzer	
	  DrvSYS_Delay(100000);	 // Delay
		DrvGPIO_ClrBit(E_GPB,11); // GPB11 = 0 to turn on Buzzer
	  DrvSYS_Delay(350000);	 // Delay 
	  DrvGPIO_SetBit(E_GPB,11); // GPB11 = 1 to turn off Buzzer	
	  DrvSYS_Delay(100000);	 // Delay
		u--;
	}
}
//******************************************************************************//

								//PART 3
// DEFINE THE BMP IMAGE FILE 
//******************************************************************************//

unsigned char Crosshair[128] = 
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x20,0x30,0x10,0x18,0x18,0x08,0x08,0xFF,0x08,0x08,0x18,0x18,0x30,0x30,0x60,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x80,0x80,0x80,0xF8,0x8E,0x81,0x81,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x87,0x9E,0xF8,0x80,0x80,0x80,
	0x01,0x01,0x01,0x01,0x0F,0x39,0xE1,0x81,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x81,0x61,0x3D,0x0F,0x00,0x01,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x02,0x06,0x04,0x0C,0x08,0x08,0x18,0xFF,0x08,0x08,0x08,0x0C,0x04,0x04,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char Bomb[64] = 
{
	0x00,0x80,0xC0,0xE0,0xE0,0xE0,0xE0,0xF0,0xD0,0xF8,0x1C,0x3C,0x7E,0x3C,0x10,0x00,
	0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFC,0x70,0x3D,0x1F,0x00,0x00,0x00,0x00,0x00
};

unsigned char Defused[64] = 
{
	0x04,0x0E,0x1F,0x3E,0x7C,0xF8,0xF0,0xE0,0xE0,0xF0,0xF8,0x7C,0x3E,0x1F,0x0E,0x04,
	0x20,0x70,0xF8,0x7C,0x3E,0x1F,0x0F,0x07,0x07,0x0F,0x1F,0x3E,0x7C,0xF8,0x70,0x20
};

unsigned char MissionFailed[512] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xE0,0xF0,0xF0,0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF0,0xF0,0xF0,0xE0,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x0F,0x07,0x03,0x03,0x03,0x03,0x03,0x07,0x07,0x9F,0xFF,0xFF,0x9F,0x07,0x07,0x03,0x03,0x03,0x03,0x03,0x07,0x0F,0xFF,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x40,0xE0,0xF0,0xF0,0xF0,0xF0,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x1E,0x3F,0x3F,0x3F,0x7F,0xFE,0xFC,0xFC,0xFC,0xFC,0xFE,0xFE,0x7F,0x1F,0x0F,0x0F,0x1F,0x7F,0xFE,0xFE,0xFC,0xFC,0xFC,0xFC,0xFE,0x7F,0x3F,0x3F,0x3F,0x1E,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF0,0xF0,0xF0,0xF0,0xE0,0x40,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xE0,0xC0,0xC0,0xC0,0x80,0x87,0x0F,0x0F,0x1F,0x1F,0x1F,0x1E,0x1E,0x1F,0x1E,0x1E,0x1F,0x1F,0x1F,0x1F,0x0F,0x0F,0x87,0x80,0xC0,0xC0,0xC0,0xE0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x70,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0x03,0x03,0x07,0x07,0x07,0x0F,0x0F,0x9F,0x9F,0xFF,0xFE,0xFE,0xFC,0xFC,0xF8,0xF8,0xF0,0xF0,0xF0,0xE4,0xE6,0xCE,0xCF,0x9F,0x9F,0x0F,0x0F,0x07,0x07,0x07,0x03,0x03,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFE,0x7E,0x3E,0x3F,0x1F,0x1F,0x0F,0x0F,0x07,0x07,0x03,0x03,0x01,0x01,0x01,0x01,0x03,0x03,0x07,0x07,0x0F,0x0F,0x1F,0x1F,0x3F,0x3E,0x7E,0xFE,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xF8,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x0F,0x1F,0x1F,0x1F,0x0F,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x0F,0x1F,0x1F,0x1F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char MissionSuccess[1024] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0xC0,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x70,0x70,0x70,0x30,0x70,0x70,0x70,0x70,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFE,0x07,0x03,0x03,0x03,0x23,0x23,0xE3,0xE3,0xE3,0xE3,0xC3,0x03,0x03,0x21,0xE1,0xF1,0xF1,0xF1,0x11,0x01,0x01,0x11,0xF1,0xF1,0xF1,0xF1,0x11,0x01,0x01,0xC1,0xF1,0xF1,0x99,0x81,0x08,0x18,0x10,0x78,0xF8,0x00,0x00,0xE0,0xF0,0xF8,0x88,0x80,0x88,0x08,0x18,0x7C,0x00,0x00,0x00,0x7C,0xFC,0xFC,0xFC,0xFC,0x04,0x00,0x00,0xF0,0xF8,0xFC,0xFC,0x04,0x00,0x04,0xFC,0xFC,0xF8,0xF0,0x80,0x00,0x06,0xCE,0x1C,0x7E,0xFE,0xFC,0xF8,0xE0,0xC2,0x06,0xFE,0x02,0x00,0x00,0x40,0xE0,0xF0,0xE0,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xDF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0xFC,0x07,0x1F,0xFF,0xFF,0x7E,0x0E,0x00,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0xF3,0xE7,0x8F,0x0F,0x1F,0x1F,0x3F,0xFF,0xFE,0x7C,0x00,0x00,0xF3,0xE7,0x87,0x0F,0x0F,0x1F,0x9F,0xFF,0x7E,0x3C,0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x03,0x1F,0x3F,0x7F,0x7F,0xC0,0x00,0x80,0xFF,0x7F,0x3F,0x1F,0x07,0x00,0x40,0x7F,0x7C,0x40,0x01,0x03,0x0F,0x1F,0x3F,0x7F,0x7E,0x00,0x00,0x00,0x00,0x38,0x78,0x38,0x30,0x00,0x00,0x00,0xFF,0xFF,0xCC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x06,0x83,0xC3,0xC2,0x40,0x03,0x40,0xC0,0xC2,0x03,0x03,0x83,0xC3,0xC3,0x62,0x00,0x62,0xC3,0xC3,0x83,0x01,0x01,0x21,0x60,0xE1,0xE1,0xE1,0x81,0x01,0x00,0xE1,0xE1,0xE0,0xE0,0x00,0x00,0x31,0xF0,0xF0,0x71,0xF0,0x11,0x71,0xF0,0xE0,0xE0,0x00,0x00,0x30,0xF0,0xF0,0xF0,0x10,0x00,0x00,0x00,0x00,0x08,0xF8,0xF8,0xF0,0xF8,0x00,0x08,0x98,0x38,0x00,0x08,0x78,0x08,0x00,0xF8,0xF8,0xF8,0xC0,0x08,0x18,0x30,0x00,0x5C,0xFC,0x7C,0xFC,0x00,0x84,0xCC,0x1C,0x3C,0x00,0x00,0x00,0x07,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x7E,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x83,0x00,0x1C,0x7F,0xFF,0xFF,0x7C,0x00,0x00,0xFF,0xFF,0xFF,0x7E,0x00,0x00,0x8C,0xE3,0x0F,0x7F,0xFF,0x3E,0x00,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x80,0x0C,0x07,0x07,0x03,0x00,0x00,0x80,0xFF,0xFF,0xFF,0x7E,0x00,0xC0,0xE0,0x78,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x43,0x47,0x70,0x78,0x00,0x00,0x00,0x40,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x20,0x3F,0x3F,0x3F,0x3E,0x00,0x23,0x32,0x3C,0x00,0x00,0x00,0x80,0xFF,0xFF,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x3F,0x3F,0x70,0x60,0x60,0x60,0x61,0x63,0x73,0x72,0x70,0x72,0x73,0x71,0x70,0x30,0x70,0x31,0x31,0x33,0x32,0x30,0x31,0x31,0x30,0x30,0x30,0x31,0x39,0x39,0x39,0x38,0x39,0x38,0x38,0x39,0x39,0x39,0x19,0x19,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1C,0x1C,0x18,0x1C,0x1C,0x1C,0x1C,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x07,0x07,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
//******************************************************************************//




							// START OF MAIN FUNCTION




//******************************************************************************//
int32_t main (void)
{
	// DEFINING ALL IMPORTANT VARIABLES
	int i,keyin, defuser = 0, PlayerOption = 0, counter = 0, leftrightsidetoside = 36, SetNum;
	int Bomb1, Bomb2, Bomb3;							// Define bomb state (1 = Armed, 0 = Defused)
	int Bomb1x, Bomb1y, Bomb2x, Bomb2y, Bomb3x, Bomb3y; // Coordinates for any bomb placements
	int x ,y ;											// For ADC x-y conversion
	uint16_t adc_value[8];
	char TEXT[4][18];

	//SELECT EXTERNAL CLOCK AND ENABLE EXTERNAL CLOCK
	UNLOCKREG();
	SYSCLK->PWRCON.XTL12M_EN = 1; 		// enable external clock (12MHz)
	DrvSYS_Delay(5000); 							// waiting for 12MHz crystal stable
	SYSCLK->CLKSEL0.HCLK_S = 0;	  		// select external clock (12MHz)
	LOCKREG();
	
	//INITIALISE LED (GPIOs) AND LCD
	init_LED();
	init_LCD();  
	clear_LCD();
	
	//SLIDING THE MAIN MENU LOGO LEFT AND RIGHT
	while (leftrightsidetoside < 57)
	{
	printS(10,7,"DEFUSE DA BOMB");
	draw_Bmp32x32(leftrightsidetoside,25,FG_COLOR,BG_COLOR,Crosshair);
	draw_Bmp16x16(56,31,FG_COLOR,BG_COLOR,Bomb);
	leftrightsidetoside++;	
	DrvSYS_Delay(5000);
	clear_LCD();		
	}
	while (leftrightsidetoside > 46)
	{
	printS(10,7,"DEFUSE DA BOMB");
	draw_Bmp32x32(leftrightsidetoside,25,FG_COLOR,BG_COLOR,Crosshair);
	draw_Bmp16x16(56,31,FG_COLOR,BG_COLOR,Bomb);
	leftrightsidetoside--;
	DrvSYS_Delay(5000);
	clear_LCD();		
	}

	//SHOWS THE GAME MAIN MENU 
	printS(10,7,"DEFUSE DA BOMB");
	draw_Bmp32x32(46,25,FG_COLOR,BG_COLOR,Crosshair);
	draw_Bmp16x16(56,31,FG_COLOR,BG_COLOR,Bomb);
	KnightRiderLED();
	
	//LARGE WHILE LOOP TO REPLAY GAME
	while(PlayerOption == 0)
	{	
	
	//INITIALISE THE RANDOM SET OF BOMB (CAN BE EDITED)
	srand(counter);					//To seed random number for rand() using incremental fixed values //Cannot use srand(time) >.< Sorry sir dunno how to use struct
	SetNum = rand() %11 + 1;		//Randomise Bomb Sets Between Value 0 until 11
	switch(SetNum) 					//Applicable Range : X-values from 10 - 106 and Y-values from 6 - 36
	{
		case 0:
			{
		Bomb1x = 10, Bomb1y = 6;
		Bomb2x = 75, Bomb2y = 16;
		Bomb3x = 90, Bomb3y = 26;
			break;				
			}
		case 1:
			{
		Bomb1x = 15, Bomb1y = 21;
		Bomb2x = 75, Bomb2y = 31;
		Bomb3x = 95, Bomb3y = 11;
			break;				
			}
		case 2:
			{
		Bomb1x = 10, Bomb1y = 36;
		Bomb2x = 106, Bomb2y = 6;
		Bomb3x = 106, Bomb3y = 36;
			break;				
			}
		case 3:
			{
		Bomb1x = 15, Bomb1y = 21;
		Bomb2x = 85, Bomb2y = 31;
		Bomb3x = 105, Bomb3y = 11;
			break;				
			}
		case 4:
			{
		Bomb1x = 10, Bomb1y = 36;
		Bomb2x = 106, Bomb2y = 6;
		Bomb3x = 106, Bomb3y = 36;
			break;				
			}
		case 5:
			{
		Bomb1x = 10, Bomb1y = 6;
		Bomb2x = 65, Bomb2y = 16;
		Bomb3x = 90, Bomb3y = 26;
			break;				
			}
		case 6:
			{
		Bomb1x = 10, Bomb1y = 6;
		Bomb2x = 50, Bomb2y = 16;
		Bomb3x = 90, Bomb3y = 26;
			break;				
			}
		case 7:
			{
		Bomb1x = 15, Bomb1y = 21;
		Bomb2x = 20, Bomb2y = 31;
		Bomb3x = 55, Bomb3y = 11;
			break;				
			}
		case 8:
			{
		Bomb1x = 10, Bomb1y = 36;
		Bomb2x = 106, Bomb2y = 6;
		Bomb3x = 106, Bomb3y = 36;
			break;				
			}
		case 9:
			{
		Bomb1x = 15, Bomb1y = 21;
		Bomb2x = 95, Bomb2y = 31;
		Bomb3x = 55, Bomb3y = 11;
			break;				
			}
		case 10:
			{
		Bomb1x = 10, Bomb1y = 36;
		Bomb2x = 106, Bomb2y = 6;
		Bomb3x = 106, Bomb3y = 36;
			break;				
			}
		case 11:
			{
		Bomb1x = 10, Bomb1y = 6;
		Bomb2x = 16, Bomb2y = 16;
		Bomb3x = 90, Bomb3y = 26;
			break;				
			}
	}
	
	//SHOW OPTION WHICH DIFFICULTY TO CHOOSE FROM
	keyin = 0;
	clear_LCD();  
	printS_5x7(20,8,"Choose Your Level:");
	printS_5x7(0,28,"1: Recruit - 1Bomb - 30s");
	printS_5x7(0,41,"2: Major - 2Bombs - 15s");
	printS_5x7(0,56,"3: Veteran - 3Bombs - 10s");
	DrvSYS_Delay(300000);
	
	//LOOP TO RECEIVE INPUT FROM USER KEYPAD (3 LEVELS), ONCE RECEIVED, SHOW LOADING SCREEN
	//INSIDE EACH CASE, ARMING THE BOMB (Bomb[i]), SETUP THE COUNTDOWN TIMER(i) AND INITIALISE TIMER[i]
	while(keyin == 0) 
	{
    keyin=ScanKey(); 
		switch(keyin)
		{		
			case 1:	
			{
			clear_LCD(); 
			print_Line(0,"      Tip :"); 
			print_Line(1,"Hold 5 To Defuse");
			printS_5x7(36,56,"ARMING THE BOMB...");
			KnightRiderLED();
			Bomb1 = 1;							// Arming 1 Bomb only
			i = 310;							// Countdown timer 30 seconds
			InitTIMER0();                       // Set Timer0 Ticking
			break;
			}	
			case 2:
			{
			clear_LCD(); 
			print_Line(0,"      Tip :"); 
			print_Line(1,"Hold 5 To Defuse");
			printS_5x7(36,56,"ARMING THE BOMB...");
			KnightRiderLED();	
			Bomb1 = 1;							// Arming 1 Bomb 
			Bomb2 = 1;							// Arming 2 Bomb 
			i = 160;							// Countdown timer 15 seconds
			InitTIMER1();                       // Set Timer1 Ticking
			break;
			}	
			case 3:	
			{
			clear_LCD(); 
			print_Line(0,"      Tip :"); 
			print_Line(1,"Hold 5 To Defuse");
			printS_5x7(36,56,"ARMING THE BOMB...");
			KnightRiderLED();	
			Bomb1 = 1;							// Arming 1 Bomb 
			Bomb2 = 1;							// Arming 2 Bomb 
			Bomb3 = 1;							// Arming 3 Bomb 
			i = 110;							// Countdown timer 10 seconds
			InitTIMER2();			     		// Set Timer2 Ticking
			break;
			}
			default: keyin = 0;					// Repeat loop until get a correct input
		}	
	}

	clear_LCD();
	

// START ADC6 AND ADC7 FOR BOMB DEFUSER
  DrvADC_Open(ADC_SINGLE_END, ADC_CONTINUOUS_OP, 0xFF, INTERNAL_HCLK, 1);
  DrvADC_EnableADCInt(AdcIntCallback, 0);
	x = 7;   // ADC7 using internal variable resistor for x-axis control              
	y = 6;   // ADC6 using internal variable resistor for x-axis control 
	gu8AdcIntFlag = 0;      
	DrvADC_StartConvert(); 

	// LEVEL 1 : RECRUIT LOOP	
	while (keyin==1)
	{	
		while(gu8AdcIntFlag==0);
		gu8AdcIntFlag=0;		     
		adc_value[x] = DrvADC_GetConversionData(x);   	// Get ADC7 value
		adc_value[y] = DrvADC_GetConversionData(y);   	// Get ADC6 value
		adc_value[x] = adc_value[x] / 43 ;				// Convert ADC7 into X-AXIS
		adc_value[y] = adc_value[y] / 135 ;				// Convert ADC6 into Y-AXIS

		draw_Bmp32x32(adc_value[x],adc_value[y],FG_COLOR,BG_COLOR,Crosshair);	// Draw crosshair
		draw_Bmp16x16(Bomb1x,Bomb1y,FG_COLOR,BG_COLOR,Bomb);					// Draw bomb 1
	
		seg_display(i);		// Show countdown timer on 7 segment (2 block)	
		i--;				// Countdown per second
		if (i< 0) break;	// Break WHILE Loop if countdown has finished
		clear_LCD();		

		// Check for keypad input 5, if X-axis and Y-axis within vicinity of bomb AND within margin, defuse the bomb and break loop.	 
		defuser=ScanKey(); 	
		if (adc_value[x] + 10 < Bomb1x + 3 && adc_value[x] + 10 > Bomb1x - 3 && adc_value[y] + 6 < Bomb1y + 3 && adc_value[y] + 6 > Bomb1y - 3 && defuser == 5)
		{	
			draw_Bmp16x16(Bomb1x - 2, Bomb1y + 2,FG_COLOR,BG_COLOR,Defused); // Show bomb is defused
			Bomb1 = 0;
			keyin=0;		// Break loop once all bomb has defused
		}
		
	}

// LEVEL 2 : MAJOR LOOP	
while (keyin == 2)
	{	
		while(gu8AdcIntFlag==0);
		gu8AdcIntFlag=0;		     
		adc_value[x] = DrvADC_GetConversionData(x);								// Get ADC7 value
		adc_value[y] = DrvADC_GetConversionData(y);   							// Get ADC6 value
		adc_value[x] = adc_value[x] / 43 ;										// Convert ADC7 into X-AXIS
		adc_value[y] = adc_value[y] / 135 ;										// Convert ADC76into X-AXIS
		draw_Bmp32x32(adc_value[x],adc_value[y],FG_COLOR,BG_COLOR,Crosshair);	// Draw crosshair
		
		// By default draw each bomb, but if each bomb is defused, each show defused bmp image instead
		if (Bomb1 == 1)	draw_Bmp16x16(Bomb1x,Bomb1y,FG_COLOR,BG_COLOR,Bomb);
		else if (Bomb1 == 0)	draw_Bmp16x16(Bomb1x - 2, Bomb1y + 2,FG_COLOR,BG_COLOR,Defused);
		if (Bomb2 == 1)	draw_Bmp16x16(Bomb2x,Bomb2y,FG_COLOR,BG_COLOR,Bomb);
		else if (Bomb2 == 0)	draw_Bmp16x16(Bomb2x - 2,Bomb2y + 2,FG_COLOR,BG_COLOR,Defused);		
		
		// If all bomb defused, break WHILE loop
		if (Bomb1 == 0 && Bomb2 == 0) keyin = 0;
		
		seg_display(i);		// Show countdown timer on 7 segment (2 block)	
		i--;				// Countdown per second
		if (i< 0) break;	// Break WHILE Loop if countdown has finished
		clear_LCD();

		// Check for keypad input 5, if X-axis and Y-axis within vicinity of bomb AND within margin, defuse each bomb.	 
		defuser=ScanKey();  
		if (adc_value[x] + 10 < Bomb1x + 3 && adc_value[x] + 10 > Bomb1x - 3 && adc_value[y] + 6 < Bomb1y + 3 && adc_value[y] + 6 > Bomb1y - 3 && defuser == 5)
		{	
			Bomb1 = 0;
		}
		else if (adc_value[x] + 10 < Bomb2x + 3 && adc_value[x] + 10 > Bomb2x - 3 && adc_value[y] + 6 < Bomb2y + 3 && adc_value[y] + 6 > Bomb2y - 3 && defuser == 5)
		{	
		Bomb2 = 0;
		}
	}
	
// LEVEL 3 : VETERAN LOOP
while (keyin == 3)
	{	
		while(gu8AdcIntFlag==0);
		gu8AdcIntFlag=0;		     
		adc_value[x] = DrvADC_GetConversionData(x);								// Get ADC7 value
		adc_value[y] = DrvADC_GetConversionData(y);   							// Get ADC6 value
		adc_value[x] = adc_value[x] / 43 ;										// Convert ADC7 into X-AXIS
		adc_value[y] = adc_value[y] / 135 ;										// Convert ADC76into X-AXIS
		draw_Bmp32x32(adc_value[x],adc_value[y],FG_COLOR,BG_COLOR,Crosshair);	// Draw crosshair
		
		// By default draw each bomb, but if each bomb is defused, each show defused bmp image instead
		if (Bomb1 == 1)	draw_Bmp16x16(Bomb1x,Bomb1y,FG_COLOR,BG_COLOR,Bomb);
		else if (Bomb1 == 0)	draw_Bmp16x16(Bomb1x - 2, Bomb1y + 2,FG_COLOR,BG_COLOR,Defused);
		if (Bomb2 == 1)	draw_Bmp16x16(Bomb2x,Bomb2y,FG_COLOR,BG_COLOR,Bomb);
		else if (Bomb2 == 0)	draw_Bmp16x16(Bomb2x - 2,Bomb2y + 2,FG_COLOR,BG_COLOR,Defused);
		if (Bomb3 == 1)	draw_Bmp16x16(Bomb3x,Bomb3y,FG_COLOR,BG_COLOR,Bomb);
		else if (Bomb3 == 0)	draw_Bmp16x16(Bomb3x - 2,Bomb3y + 2,FG_COLOR,BG_COLOR,Defused);		
		
		// If all bomb defused, break WHILE loop
		if (Bomb1 == 0 && Bomb2 == 0 && Bomb3 ==0 ) keyin = 0;
		
		seg_display(i);		// Show countdown timer on 7 segment (2 block)	
		i--;				// Countdown per second
		if (i< 0) break;	// Break WHILE Loop if countdown has finished
		clear_LCD();

		// Check for keypad input 5, if X-axis and Y-axis within vicinity of bomb AND within margin, defuse each bomb.	 	 
		defuser=ScanKey(); 
		if (adc_value[x] + 10 < Bomb1x + 3 && adc_value[x] + 10 > Bomb1x - 3 && adc_value[y] + 6 < Bomb1y + 3 && adc_value[y] + 6 > Bomb1y - 3 && defuser == 5)
		{	
			Bomb1 = 0;
		}
		else if (adc_value[x] + 10 < Bomb2x + 3 && adc_value[x] + 10 > Bomb2x - 3 && adc_value[y] + 6 < Bomb2y + 3 && adc_value[y] + 6 > Bomb2y - 3 && defuser == 5)
		{	
		Bomb2 = 0;
		}
		else if (adc_value[x] + 10 < Bomb3x + 3 && adc_value[x] + 10 > Bomb3x - 3 && adc_value[y] + 6 < Bomb3y + 3 && adc_value[y] + 6 > Bomb3y - 3 && defuser == 5)
		{	
			Bomb3 = 0;
		}
	}	

// START END OF GAME PROCESS		
DrvSYS_Delay(100000);
clear_LCD();

	// CHECK IF COUNTER i > 0, 
	if (i > 0)			// If all bomb has been successfully diffused in time
	{
	draw_LCD(MissionSuccess);
	BombDefused();
	CelebrationLED();
	}
	else 				// If one of the bomb(s) has not been diffused in time
	{
	draw_Bmp64x64(32,0,FG_COLOR,BG_COLOR,MissionFailed);
	BombDetonate();
	DrvSYS_Delay(300000);
	}

	counter++;			// Counter for how many times player has played the game		
	PlayerOption = 1;	// Set condition to loop if player wants to play the game again

	//DISABLE ALL TIMERS AND LED TO AVOID INTERRUPTION IN THE NEXT ROUND 									
	DisableTIMER0();
	DisableTIMER1();
	DisableTIMER2();
  	DisableLED();
	
	// SHOW REPLAY MENU PAGE
	clear_LCD();
 	sprintf(TEXT[2],"Played : %1d Times",counter); 
	printS_5x7(29,7, TEXT[2]);		              	// Show how many times player has played the game 
	printS_5x7(38,23,"Play Again?");
	printS_5x7(12,38,"1 to 9 : Let's Go ^_^ ");
	printS_5x7(12,54,"5 : Give up ---> EXIT");
	while(PlayerOption  == 1) 
	{
		keyin=ScanKey(); 
		switch(keyin)
		{			
			case 1: PlayerOption = 0; break;
			case 2: PlayerOption = 0; break;
			case 3: PlayerOption = 0; break;
			case 4: PlayerOption = 0; break;
			case 6: PlayerOption = 0; break;
			case 7: PlayerOption = 0; break;
			case 8: PlayerOption = 0; break;
			case 9: PlayerOption = 0; break;  
			case 5:									// EXIT if player gives up :P
			{
				PlayerOption = 2;
				clear_LCD(); 
				print_Line(1,"     THANK");	
				print_Line(2,"      YOU"); 	
				DrvSYS_Delay(300000);
				break;
			}
			default: break;
		}	
	}
	}
}
//******************************************************************************//


						// END OF MAIN AND END OF PROGRAMME//
